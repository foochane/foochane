---
title: Java常见问题汇总
date: 2020-05-20 10:00:00
urlname: 2020052501
categories: Java
tags:
  - Java
author: foochane
toc: true
mathjax: true
top: false
top_img: /images/banner/0.jpg
cover: /images/cover/16.jpg
---

# 1 Java基础

## 1.1 基础概念

### 1 什么是Java？




**概念**

Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。

**Java的特点**

简单性、面向对象、分布式、健壮性、安全性、体系结构中立、可移植性、解释性、高性能、多线程、动态性

**Java版本变化**

| 时间           | 版本                | 特性                                                         |
| -------------- | ------------------- | ------------------------------------------------------------ |
| 1995年5月23日  | Java语言诞生        |                                                              |
| 1996年 1月23日 | JDK 1.0             | 初代版本，伟大的一个里程碑，但是是纯解释运行，使用外挂JIT，性能比较差，运行速度慢 |
| 1997年 2月19日 | JDK1.1              | ①JDBC(Java DataBase Connectivity) <br>②支持内部类<br> RMI(Remote Method Invocation) <br>③反射<br>④ Java Bean |
| 1998年12月08日 | J2SE1.2             | ①JIT(Just In Time)编译器<br>②对打包的Java文件进行数字签名<br>③JFC(Java Foundation Classes), 包括Swing 1.0, 拖放和Java2D类库<br>④Java插件<br>⑤JDBC中引入可滚动结果集,BLOB,CLOB,批量更新和用户自定义类型<br>⑥Applet中添加声音支持<br>⑦集合框架 |
| 2000年05月08月 | J2SE1.3             | ①引入Java Sound API<br>②Jar文件索引<br>③对Java的各个方面做了大量的优化和增强 |
| 2004年02月06日 | J2SE1.4             | ①XML处理<br/>②Java打印服务<br/>③引入Logging API<br/>④引入Java Web Start<br/>⑤引入JDBC3.0<br/>⑥引入断言<br/>⑦引入Preferences API<br/>⑧引入链式异常处理<br/>⑨支持IPv6   安全套接字（Socket）支持（通过SSL与TLS协议）<br/>⑩只是正则表达式<br/>⑪引入Image I/O slot machine API |
| 2004年09月30日 | J2SE1.5/JAVA SE 5.0 | ①引入泛型<br/>②增强循环，可以使用迭代方式<br/>③自动装箱，自动拆箱<br/>④类型安全枚举<br/>⑤可变参数<br/>⑥静态引入<br/>⑦元数据（注解）<br/>⑧引入Instrumentation |
| 2006年12月11日 | JAVA SE 6           | ①支持脚本语言<br/>②引入JDBC4.0 API<br/>③引入Java Compiler API<br/>④可插拔注解<br/>⑤增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持<br/>⑥继承Web Services<br/>⑦做了很多优化 |
| 2011年07月28日 | JAVA SE 7           | ①switch语句块中允许以字符串作为分支条件<br/>②在创建泛型对象时应用类型推断<br/>③在一个语句块中捕获多种异常<br/>④支持动态语言<br/>⑤支持try-with-resources<br/>⑥引入Java NIO.2开发包<br/>⑦数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线<br/>⑧钻石型语法<br/>⑨null值的自动处理 |
| 2014年3月19号  | JAVA SE 8           | ①接口默认方法<br/>②Lambda表达式<br/>③函数式接口<br/>④方法与构造函数引用<br/>⑤Lambda作用域<br/>⑥访问局部变量<br/>⑦访问对象字段与静态变量<br/>⑧访问接口的默认方法<br/>⑨Date API<br/>⑩Annotation（注解） |
| 2017年9月22日  | JAVA SE 9           | ①模块系统<br/>②REPL (JShell)<br/>③HTTP 2 客户端<br/>④改进的 Javadoc<br/>⑤多版本兼容 JAR 包<br/>⑥集合工厂方法<br/>⑦改进 try-with-resources<br/>⑧改进的弃用注解 @Deprecated<br/>⑨改进钻石操作符(Diamond Operator)<br/>⑩响应式流（Reactive Streams) API |
| 2018年3月21    | JAVA SE 10          | ①var 局部变量类型推断<br/>②将原来用 Mercurial 管理的众多 JDK 仓库代码，合并到一个仓库中<br/>③统一的垃圾回收接口<br/>④G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟<br/>⑤应用程序类数据 (AppCDS) 共享<br/>⑥ThreadLocal 握手交互<br/>⑦移除 JDK 中附带的 javah 工具，可以使用 javac -h 代替<br/>⑧使用附加的 Unicode 语言标记扩展<br/>⑨能将堆内存占用分配给用户指定的备用内存设备<br/>⑩使用 Graal 基于 Java 的编译器 |
| 2018年9月25日  | JAVA SE 11          | ①Nest-Based访问控制<br/>②动态类文件常量<br/>③改善Aarch64 intrinsic<br/>④无操作垃圾收集器<br/>⑤消除Java EE和CORBA模块<br/>⑥HTTP客户端(标准)<br/>⑦局部变量的语法λ参数<br/>⑧Curve25519和Curve448关键协议<br/>⑨低开销堆分析<br/>⑩反对Nashorn JavaScript引擎<br/>⑪反对Pack200工具和API |
| 2019年3月19日  | JAVA SE 12          | ①新增一个名为 Shenandoah 的垃圾回收器<br/>②新增一套微基准测试<br/>③对 switch 语句进行扩展<br/>④删除与 arm64 端口相关的所有源码<br/>⑤默认生成类数据共享（CDS）存档<br/>⑥当 G1 垃圾回收器的回收超过暂停目标，则能中止垃圾回收过程<br/>⑦改进 G1 垃圾回收器，以便在空闲时自动将 Java 堆内存返回给操作系统 |
| 2019年9月      | JAVA SE 13          |                                                              |



### 2 Java如何实现跨平台？

平台性是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。

实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。

### 3 JVM、JRE和JDK的关系？

- JVM：Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。

- JRE：Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。

- JDK：Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等
  

### 4 Java和C++的区别？

- 都是面向对象的语言，都支持封装、继承和多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。
- Java有自动内存管理机制，不需要程序员手动释放无用内存

### 5 Oracle JDK 和 OpenJDK 的区别？

- Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；
- OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；
- Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；
- 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；
- Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；
- Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。

### 6 什么是字节码？采用字节码有什么好处？

- 字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。

- 字节码的好处：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

- java中的编译器和解释器：Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。**Java源程**序经过编译器编译后变成**字节码**，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的**机器码**，然后在特定的机器上**运行**，这就是上面提到的Java的特点的编译与解释并存的解释



## 1.2 基础语法

### 1 Java的数据类型有哪些？

Java的数据类型分为两大类：

- 基本数据类型 ：整数 、 浮点数 、 字符 、 布尔 。
- 引用数据类型 ：类 、 数组 、 接口 。

| 数据类型     | 关键字         | 占用内存 | 取值范围              |
| ------------ | -------------- | -------- | --------------------- |
| 字节型       | byte           | 1个字节  | -128~127              |
| 短整型       | short          | 2个字节  | -32768~32767          |
| 整型         | int（默认）    | 4个字节  | $-2^{31}$~$2^{31}-1$  |
| 长整型       | long           | 8个字节  | $-2^{63}$~$2^{63}-1$  |
| 单精度浮点数 | float          | 4个字节  | 1.4013E-45~3.4028E+38 |
| 双精度浮点数 | double（默认） | 8个字节  | 4.9E-324~1.7977E+308  |
| 字符型       | char           | 2个字节  | 0-65535               |
| 布尔类型     | boolean        | 1个字节  | true，false           |





### 2 修饰符 public、protecte、default、private的区别？

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，

- public ：公共的。
- protected ：受保护的
- default ：默认的
- private ：私有的

不同权限的访问能力:

| 类                     | public | protected | default（空的） | private |
| ---------------------- | ------ | --------- | --------------- | ------- |
| 同一类中               | YES    | YES       | YES             | YES     |
| 同一包中(子类与无关类) | YES    | YES       | YES             | NO      |
| 不同包的子类           | YES    | YES       | NO              | NO      |
| 不同包中的无关类       | YES    | NO        | NO              | NO      |

可见，public具有最大权限。private则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

- 成员变量使用 private ，隐藏细节。
- 构造方法使用 public ，方便创建对象。
- 成员方法使用 public ，方便调用方法。

**注意：不加权限修饰符，其访问能力与default修饰符相同**

### 3 运算符&& 和& 的区别？

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。



### 4 this与super的区别？

- this是自身的一个对象，代表对象本身，指向当前对象本身

- super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类



### 5 final、finally、finalize区别？

- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块
  中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调
  用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的
  最后判断。

### 6 static关键字的作用和用法？

static的主要意义是在于创建独立于具体对象的域变量或者方法。**即使没有创建对象，也能使用属性和调用方法**

- static方法
  　1. static方法一般称作静态方法，静态方法不依赖于任何对象就可以进行访问。建议直接使用类名调用。
   　2. 在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用
   　3. 非静态成员方法中是可以访问静态成员方法/变量的

- static变量
  静态变量被所有对象共享，在内存中只有一个副本，在类初次加载的时候才会初始化非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

> **静态方法/变量不属于任何一个实例对象，而是被类的实例对象所共享**

- static代码块
  1. **随着类的加载而执行且执行一次，优先于 main方法和构造方法的执行**
  2. 静态初始化块的作用就是：提升程序性能。

### 7 break ,continue ,return 的区别及作用

- break 跳出总上一层循环，不再执行循环(结束当前的循环体)

- continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)

- return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)







## 1.3 面向对象

### 1 什么是面向对象？

面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。



> **抽象**：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

### 2 类和对象的区别？

- 类 ：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该

  类事物。

  - 属性：事物的状态信息。
  - 行为：事物能够做什么。

- 对象 ：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为。

- 类与对象的关系

  - 类是对一类事物的描述，是**抽象的**。
  - 对象是一类事物的实例，是**具体的**。
  - 类是对象的模板，对象是类的实体 。

### 3 面向对象的三大特性是什么？

- 封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。

  封装的步骤：

  1. 使用 private 关键字来修饰成员变量。
  2. 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。

- 继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。子类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

  特点：

  1. 类拥有父类非 private 的属性和方法。

  2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。

  3. 子类可以用自己的方式实现父类的方法。

  好处:

  1. 提高代码的复用性。
  2. 类与类之间产生了关系，是多态的前提。

- 多态： 是指同一行为，具有多个不同表现形式。指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

  在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

  多态的好处：实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。

### 4  equals (）和hashCode() 

- equals()方法

  - equals()方法java.lang.Object类中方法，equals()方法是用来判断其他的对象是否和该对象相等。

  - equals()方法的约定（Object规范）
    1. 自反性（reflexive）：对于任意不为null的引用值x，x.equals(x)一定是true。

    2. 对称性（symmetric）：对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。

    3. 传递性（transitive）：对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。

    4. 一致性（consistent）：对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。
    5. 对于任意不为null的引用值x，x.equals(null)返回false。

- hashCode()

  - hashCode()同样是java.lang.Object类中的一个本地方法（Native Method），作用是用来获取对象的哈希码（hash code），也叫散列码，哈希码是一个整形（int）。
  
  - hashCode的约定（Object规范）
  
    1. 在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个值。
  
    2. 如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个整数结果。
  
    3. 并不要求根据equals()方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。
  
  > 参考《Effective Java中文版》第3版，第10、11条

- 相关问题

  1. equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？

     因为重写的equals（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。

  2. hashCode()既然效率这么高为什么还要equals()呢？

     因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题，哈希冲突），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。一般来说：

     - equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。
     - hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。

  





### 5 == 和 equals 的区别是什么

- == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)

- equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

  情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。

  情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。



> String类中的equals()方法是被重写过的。


### 6 重载（Overload）和重写（Override）的区别?

- 重载：发生在**同一个类中**，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分

- 重写：发生在**父子类中**，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。
- 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。


### 7 构造器（constructor）是否可被重写（override）?

构造器不能被继承，因此不能被重写，但可以被重载。



### 8 抽象类和接口有什么区别？

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

**不同点：**

抽象类：
1.抽象类中可以定义构造器
2.可以有抽象方法和具体方法
3.接口中的成员全都是 public 的
4.抽象类中可以定义成员变量
5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法
6.抽象类中可以包含静态方法
7.一个类只能继承一个抽象类

接口：
1.接口中不能定义构造器
2.方法全部都是抽象方法
3.抽象类中的成员可以是 private、默认、protected、public
4.接口中定义的成员变量实际上都是常量
5.接口中不能有静态方法
6.一个类可以实现多个接口

**相同点：**
1.不能够实例化
2.可以将抽象类和接口类型作为引用类型
3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要
被声明为抽象类

## 1.4 String相关



### 1 String 和 StringBuffer、StringBuilder 的区别是什么？

- 可变性

  String类中使用字符数组保存字符串，private　final　char　value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。

- 线程安全性

  String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。

- 性能

  每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

- 对于三者使用的总结
  - 如果要操作少量的数据用 String
  - 单线程操作字符串缓冲区下操作大量数据使用StringBuilder
  - 多线程操作字符串缓冲区下操作大量数据使用StringBuffer





## 1.5 IO流相关



## 1.6 反射相关



### 1 什么是反射机制？

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

静态编译和动态编译

**静态编译：**在编译时确定类型，绑定对象
**动态编译：**运行时确定类型，绑定对象

### 2 反射机制的应用场景有哪些？

反射是框架设计的灵魂。

在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。

举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性





### 3 反射机制优缺点？

- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。
- **缺点：** 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。



### 4 Java获取反射的三种方法？

- 通过new对象实现反射机制
- 通过路径实现反射机制
- 通过类名实现反射机制

```java
public class Student {
    private int id;
    String name;
    protected boolean sex;
    public float score;
}
```



```java
public class Get {
    //获取反射机制三种方式
    public static void main(String[] args) throws ClassNotFoundException {
        //方式一(通过建立对象)
        Student stu = new Student();
        Class classobj1 = stu.getClass();
        System.out.println(classobj1.getName());
        //方式二（所在通过路径-相对路径）
        Class classobj2 = Class.forName("fanshe.Student");
        System.out.println(classobj2.getName());
        //方式三（通过类名）
        Class classobj3 = Student.class;
        System.out.println(classobj3.getName());
    }
}
```





## 1.3 集合

### 1 常用的集合类有哪些？

![Collection集合](https://foochane.cn/images/2020/002.png)



![Map集合](https://foochane.cn/images/2020/003.png)





> 颜色含义：黄色：代表接口 绿色：代表抽象接口 蓝色：代表实现类



主要包含Collection集合和Map集合：

**Collection集合**

- List
  - ArrayList：基于动态数组实现，支持随机访问。
  - Vector：和 ArrayList 类似，但它是线程安全的。
  - LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。

- Set
  - TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
  -  HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
  -  LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。

- Queue
  - LinkedList：可以用它来实现双向队列。
  - PriorityQueue：基于堆结构实现，可以用它来实现优先队列。

**Map集合**

- HashMap：基于哈希表实现。JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。
- LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。
- HashTable：数组+链表组成的。和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。
- TreeMap：基于红黑树实现。



### 2 ArrayList的优缺点？

ArrayList的优点如下：

- ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。
- ArrayList 在顺序添加一个元素的时候非常方便。

ArrayList 的缺点如下：

- 删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。
- 插入元素的时候，也需要做一次元素复制操作，缺点同上。



>  ArrayList 比较适合顺序添加、随机访问的场景。



### 3 ArrayList 和 LinkedList 的区别是什么？

- 数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。
- 随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。
- 增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。

- 内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。
- 线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；



> 综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。





### 4 ArrayList 和 Vector 的区别是什么？

这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合

- 线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。
- 性能：ArrayList 在性能方面要优于 Vector。
- 扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。
- Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。
- Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。



### 5  多线程场景下如何使用 ArrayList？

ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：

```java
List<String> synchronizedList = Collections.synchronizedList(list);
synchronizedList.add("aaa");
synchronizedList.add("bbb");

for (int i = 0; i < synchronizedList.size(); i++) {
    System.out.println(synchronizedList.get(i));
}
```



### 6 List 和 Set 的区别

List , Set 都是继承自Collection 接口

- List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。

- Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。

- List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。



Set和List对比

- Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
- List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变

### 7 HashSet是如何保证数据不可重复的？

向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。
HashSet 中的add ()方法会使用HashMap 的put()方法。

HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。

### 8 说一下 HashMap 的实现原理？

**数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；\**所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做**拉链法的方式可以解决哈希冲突。

JDK1.8之前采用的是拉链法。**拉链法**：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。

JDK1.8主要解决或优化了一下问题：

1. resize 扩容优化
2. 引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考
3. 解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。



### 9 HashMap的put方法的具体流程？

当我们put的时候，首先计算 key的hash值，这里调用了 hash方法，hash方法实际是让key.hashCode()与key.hashCode()>>>16进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) & hash，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。

putVal方法执行流程图

![](https://foochane.cn/images/2020/004.png)



### 10 HashMap是怎么解决哈希冲突的？

- 哈希
  Hash，一般翻译为“散列”，也有直接音译为“哈希”的，这就是把任意长度的输入通过散列算法，变换成固定长度的输出，该输出就是散列值（哈希值）；这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。

  所有散列函数都有如下一个基本特性**：根据同一散列函数计算出的散列值如果不同，那么输入值肯定也不同。但是，根据同一散列函数计算出的散列值如果相同，输入值不一定相同**。

- 哈希冲突
  当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。

- hash()函数
  上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为**扰动**
  这比在**JDK 1.7**中，更为简洁，**相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）**

- JDK1.8新增红黑树

  通过上面的链地址法（使用散列表）和扰动函数我们成功让我们的数据分布更平均，哈希碰撞减少，但是当我们的HashMap中存在大量数据时，加入我们某个bucket下对应的链表有n个元素，那么遍历时间复杂度就为O(n)，为了针对这个问题，JDK1.8在HashMap中新增了红黑树的数据结构，进一步使得遍历复杂度降低至O(logn)；

- **总结**
  HashMap是使用了哪些方法来有效解决哈希冲突的：
  1. **使用链地址法（使用散列表）来链接拥有相同hash值的数据；**
  2. **使用2次扰动函数（hash函数）来降低哈希冲突的概率，使得数据分布更平均；**
  3. **引入红黑树进一步降低遍历的时间复杂度，使得遍历更快；**


### 11 能否使用任何类作为 Map 的 key？

可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：

- 如果类重写了 equals() 方法，也应该重写 hashCode() 方法。

- 类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。

- 如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。

- 用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。

### 12 为什么HashMap中String、Integer这样的包装类适合作为K？

String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率。

因为：

1. 都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况
2. 内部已重写了equals()、hashCode()等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；

### 13 如果使用Object作为HashMap的Key，应该怎么办呢？

重写hashCode()和equals()方法

- 重写hashCode()是因为需要计算存储数据的存储位置，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；

- 重写equals()方法，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；



### 14 HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？

hashCode()方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode()计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；

那怎么解决呢？

- HashMap自己实现了自己的hash()方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；
- 在保证数组长度为2的幂次方的时候，使用hash()运算之后的值与运算（&）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；





### 15 HashMap 与 HashTable 有什么区别？

1. 线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（**如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！**）；
2. 效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；
3. 对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。
   **初始容量大小和每次扩充容量大小的不同 **： ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。
4. 底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。
5. 推荐使用：在 Hashtable 的类注释可以看到**，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。**
   



### 16 如何决定使用 HashMap 还是 TreeMap？

对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。

### 17 HashMap 和 ConcurrentHashMap 的区别？

1. ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）
2. HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。



### 18 ConcurrentHashMap 和 Hashtable 的区别？

ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。

- 底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；
- 实现线程安全的方式（重要）： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。



### 19 Collection 和 Collections 有什么区别？

- java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。

- Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。



### 20 TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？

TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。

Collections 工具类的 sort 方法有两种重载的形式，

第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；

第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。




> 参考：

1. https://blog.csdn.net/wangwei_620/article/details/82049502
2. https://blog.csdn.net/feiyanaffection/article/details/81394745

## 1.2 异常



## 1.4 并发



## 1.5 JVM



# 2 数据库

## 2.1 MySQL



## 2.2 Redis



# 3 常用框架

## 3.1 Spring



## 3.2 Spring Boot



## 3.3 Spring Cloud



## 3.4 Mybatis





# 4 算法与数据结构



# 5 其他技术







# 6 补充知识点

## 6.1 什么是原码、反码、补码？

### 概念

原码、反码、补码是计算机中对数字的二进制表示方法。

- 原码：将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字表示方式。

- 反码：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。

- 补码：如果是整数，则表示方法和原码一样；如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）。



**反码的反码为原码，补码的补码为原码**



### 示例

假设为8-bit的整数

| 数字 | 原码       | 补码       | 反码       |
| ---- | ---------- | ---------- | ---------- |
| 6    | 0 000 0110 | 0 000 0110 | 0 000 0110 |
| -6   | 1 000 0110 | 1 111 1001 | 1 111 1010 |



### 二进制数的运算

二进制数的减法用两数的补码相加再去补码来完成，乘法用加法和位移实现，除法用减法和位移来实现。







# 参考



1. https://www.nowcoder.com/tutorial/94/ea1986fcff294f6292385703e94689e8
2. https://thinkwon.blog.csdn.net/article/details/104390612
3. https://how2j.cn/
4. https://cyc2018.github.io/CS-Notes/#/README