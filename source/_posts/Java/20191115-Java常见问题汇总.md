---
title: Java常见问题汇总
date: 2019-11-15 22:00:00
urlname: 2019111501
categories: Java
tags:
  - Java
author: foochane
toc: true
mathjax: true
top: false
top_img: /images/banner/0.jpg
cover: /images/cover/14.jpg

---

# 1 Java基础

## 1.1 基础概念

### 1 什么是Java？

**概念**

Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程。

**Java的特点**

简单性、面向对象、分布式、健壮性、安全性、体系结构中立、可移植性、解释性、高性能、多线程、动态性

**Java版本变化**

| 时间           | 版本                | 特性                                                         |
| -------------- | ------------------- | ------------------------------------------------------------ |
| 1995年5月23日  | Java语言诞生        |                                                              |
| 1996年 1月23日 | JDK 1.0             | 初代版本，伟大的一个里程碑，但是是纯解释运行，使用外挂JIT，性能比较差，运行速度慢 |
| 1997年 2月19日 | JDK1.1              | ①JDBC(Java DataBase Connectivity) <br>②支持内部类<br> RMI(Remote Method Invocation) <br>③反射<br>④ Java Bean |
| 1998年12月08日 | J2SE1.2             | ①JIT(Just In Time)编译器<br>②对打包的Java文件进行数字签名<br>③JFC(Java Foundation Classes), 包括Swing 1.0, 拖放和Java2D类库<br>④Java插件<br>⑤JDBC中引入可滚动结果集,BLOB,CLOB,批量更新和用户自定义类型<br>⑥Applet中添加声音支持<br>⑦集合框架 |
| 2000年05月08月 | J2SE1.3             | ①引入Java Sound API<br>②Jar文件索引<br>③对Java的各个方面做了大量的优化和增强 |
| 2004年02月06日 | J2SE1.4             | ①XML处理<br/>②Java打印服务<br/>③引入Logging API<br/>④引入Java Web Start<br/>⑤引入JDBC3.0<br/>⑥引入断言<br/>⑦引入Preferences API<br/>⑧引入链式异常处理<br/>⑨支持IPv6   安全套接字（Socket）支持（通过SSL与TLS协议）<br/>⑩只是正则表达式<br/>⑪引入Image I/O slot machine API |
| 2004年09月30日 | J2SE1.5/JAVA SE 5.0 | ①引入泛型<br/>②增强循环，可以使用迭代方式<br/>③自动装箱，自动拆箱<br/>④类型安全枚举<br/>⑤可变参数<br/>⑥静态引入<br/>⑦元数据（注解）<br/>⑧引入Instrumentation |
| 2006年12月11日 | JAVA SE 6           | ①支持脚本语言<br/>②引入JDBC4.0 API<br/>③引入Java Compiler API<br/>④可插拔注解<br/>⑤增加对Native PKI(Public Key Infrastructure)、Java GSS(Generic Security Service)、Kerberos和LDAP(Lightweight Directory Access Protocol)的支持<br/>⑥继承Web Services<br/>⑦做了很多优化 |
| 2011年07月28日 | JAVA SE 7           | ①switch语句块中允许以字符串作为分支条件<br/>②在创建泛型对象时应用类型推断<br/>③在一个语句块中捕获多种异常<br/>④支持动态语言<br/>⑤支持try-with-resources<br/>⑥引入Java NIO.2开发包<br/>⑦数值类型可以用2进制字符串表示，并且可以在字符串表示中添加下划线<br/>⑧钻石型语法<br/>⑨null值的自动处理 |
| 2014年3月19号  | JAVA SE 8           | ①接口默认方法<br/>②Lambda表达式<br/>③函数式接口<br/>④方法与构造函数引用<br/>⑤Lambda作用域<br/>⑥访问局部变量<br/>⑦访问对象字段与静态变量<br/>⑧访问接口的默认方法<br/>⑨Date API<br/>⑩Annotation（注解） |
| 2017年9月22日  | JAVA SE 9           | ①模块系统<br/>②REPL (JShell)<br/>③HTTP 2 客户端<br/>④改进的 Javadoc<br/>⑤多版本兼容 JAR 包<br/>⑥集合工厂方法<br/>⑦改进 try-with-resources<br/>⑧改进的弃用注解 @Deprecated<br/>⑨改进钻石操作符(Diamond Operator)<br/>⑩响应式流（Reactive Streams) API |
| 2018年3月21    | JAVA SE 10          | ①var 局部变量类型推断<br/>②将原来用 Mercurial 管理的众多 JDK 仓库代码，合并到一个仓库中<br/>③统一的垃圾回收接口<br/>④G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟<br/>⑤应用程序类数据 (AppCDS) 共享<br/>⑥ThreadLocal 握手交互<br/>⑦移除 JDK 中附带的 javah 工具，可以使用 javac -h 代替<br/>⑧使用附加的 Unicode 语言标记扩展<br/>⑨能将堆内存占用分配给用户指定的备用内存设备<br/>⑩使用 Graal 基于 Java 的编译器 |
| 2018年9月25日  | JAVA SE 11          | ①Nest-Based访问控制<br/>②动态类文件常量<br/>③改善Aarch64 intrinsic<br/>④无操作垃圾收集器<br/>⑤消除Java EE和CORBA模块<br/>⑥HTTP客户端(标准)<br/>⑦局部变量的语法λ参数<br/>⑧Curve25519和Curve448关键协议<br/>⑨低开销堆分析<br/>⑩反对Nashorn JavaScript引擎<br/>⑪反对Pack200工具和API |
| 2019年3月19日  | JAVA SE 12          | ①新增一个名为 Shenandoah 的垃圾回收器<br/>②新增一套微基准测试<br/>③对 switch 语句进行扩展<br/>④删除与 arm64 端口相关的所有源码<br/>⑤默认生成类数据共享（CDS）存档<br/>⑥当 G1 垃圾回收器的回收超过暂停目标，则能中止垃圾回收过程<br/>⑦改进 G1 垃圾回收器，以便在空闲时自动将 Java 堆内存返回给操作系统 |
| 2019年9月      | JAVA SE 13          |                                                              |



### 2 Java如何实现跨平台？

平台性是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。

实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。

### 3 JVM、JRE和JDK的关系？

- JVM：Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。

- JRE：Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包。如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。

- JDK：Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等
  

### 4 Java和C++的区别？

- 都是面向对象的语言，都支持封装、继承和多态
- Java不提供指针来直接访问内存，程序内存更加安全
- Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。
- Java有自动内存管理机制，不需要程序员手动释放无用内存

### 5 Oracle JDK 和 OpenJDK 的区别？

- Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；
- OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；
- Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；
- 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；
- Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；
- Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。

### 6 什么是字节码？采用字节码有什么好处？

- 字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。

- 字节码的好处：Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。

- java中的编译器和解释器：Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。**Java源程**序经过编译器编译后变成**字节码**，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的**机器码**，然后在特定的机器上**运行**，这就是上面提到的Java的特点的编译与解释并存的解释



## 1.2 基础语法

### 1 Java的数据类型有哪些？

Java的数据类型分为两大类：

- 基本数据类型 ：整数 、 浮点数 、 字符 、 布尔 。
- 引用数据类型 ：类 、 数组 、 接口 。

| 数据类型     | 关键字         | 占用内存 | 取值范围              |
| ------------ | -------------- | -------- | --------------------- |
| 字节型       | byte           | 1个字节  | -128~127              |
| 短整型       | short          | 2个字节  | -32768~32767          |
| 整型         | int（默认）    | 4个字节  | $-2^{31}$~$2^{31}-1$  |
| 长整型       | long           | 8个字节  | $-2^{63}$~$2^{63}-1$  |
| 单精度浮点数 | float          | 4个字节  | 1.4013E-45~3.4028E+38 |
| 双精度浮点数 | double（默认） | 8个字节  | 4.9E-324~1.7977E+308  |
| 字符型       | char           | 2个字节  | 0-65535               |
| 布尔类型     | boolean        | 1个字节  | true，false           |





### 2 修饰符 public、protecte、default、private的区别？

在Java中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，

- public ：公共的。
- protected ：受保护的
- default ：默认的
- private ：私有的

不同权限的访问能力:

| 类                     | public | protected | default（空的） | private |
| ---------------------- | ------ | --------- | --------------- | ------- |
| 同一类中               | YES    | YES       | YES             | YES     |
| 同一包中(子类与无关类) | YES    | YES       | YES             | NO      |
| 不同包的子类           | YES    | YES       | NO              | NO      |
| 不同包中的无关类       | YES    | NO        | NO              | NO      |

可见，public具有最大权限。private则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

- 成员变量使用 private ，隐藏细节。
- 构造方法使用 public ，方便创建对象。
- 成员方法使用 public ，方便调用方法。

**注意：不加权限修饰符，其访问能力与default修饰符相同**

### 3 运算符&& 和& 的区别？

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。



### 4 this与super的区别？

- this是自身的一个对象，代表对象本身，指向当前对象本身

- super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类



### 5 final、finally、finalize区别？

- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块
  中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调
  用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的
  最后判断。

### 6 static关键字的作用和用法？

static的主要意义是在于创建独立于具体对象的域变量或者方法。**即使没有创建对象，也能使用属性和调用方法**

- static方法
  　1. static方法一般称作静态方法，静态方法不依赖于任何对象就可以进行访问。建议直接使用类名调用。
   　2. 在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用
   　3. 非静态成员方法中是可以访问静态成员方法/变量的

- static变量
  静态变量被所有对象共享，在内存中只有一个副本，在类初次加载的时候才会初始化非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

> **静态方法/变量不属于任何一个实例对象，而是被类的实例对象所共享**

- static代码块
  1. **随着类的加载而执行且执行一次，优先于 main方法和构造方法的执行**
  2. 静态初始化块的作用就是：提升程序性能。

### 7 break ,continue ,return 的区别及作用

- break 跳出总上一层循环，不再执行循环(结束当前的循环体)

- continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)

- return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)







## 1.3 面向对象

### 1 什么是面向对象？

面向对象思想是一种程序设计思想，我们在面向对象思想的指引下，使用Java语言去设计、开发计算机程序。 这里的对象泛指现实中一切事物，每种事物都具备自己的属性和行为。面向对象思想就是在计算机程序设计过程中，参照现实中事物，将事物的属性特征、行为特征抽象出来，描述成计算机事件的设计思想。 它区别于面向过程思想，强调的是通过调用对象的行为来实现功能，而不是自己一步一步的去操作实现。



> **抽象**：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

### 2 类和对象的区别？

- 类 ：是一组相关属性和行为的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该

  类事物。

  - 属性：事物的状态信息。
  - 行为：事物能够做什么。

- 对象 ：是一类事物的具体体现。对象是类的一个实例，必然具备该类事物的属性和行为。

- 类与对象的关系

  - 类是对一类事物的描述，是**抽象的**。
  - 对象是一类事物的实例，是**具体的**。
  - 类是对象的模板，对象是类的实体 。

### 3 面向对象的三大特性是什么？

- 封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。

  封装的步骤：

  1. 使用 private 关键字来修饰成员变量。
  2. 对需要访问的成员变量，提供对应的一对 getXxx 方法 、 setXxx 方法。

- 继承：就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。子类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。

  特点：

  1. 类拥有父类非 private 的属性和方法。

  2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。

  3. 子类可以用自己的方式实现父类的方法。

  好处:

  1. 提高代码的复用性。
  2. 类与类之间产生了关系，是多态的前提。

- 多态： 是指同一行为，具有多个不同表现形式。指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

  在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。

  多态的好处：实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。

### 4  equals (）和hashCode() 

- equals()方法

  - equals()方法java.lang.Object类中方法，equals()方法是用来判断其他的对象是否和该对象相等。

  - equals()方法的约定（Object规范）
    1. 自反性（reflexive）：对于任意不为null的引用值x，x.equals(x)一定是true。

    2. 对称性（symmetric）：对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。

    3. 传递性（transitive）：对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。

    4. 一致性（consistent）：对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。
    5. 对于任意不为null的引用值x，x.equals(null)返回false。

- hashCode()

  - hashCode()同样是java.lang.Object类中的一个本地方法（Native Method），作用是用来获取对象的哈希码（hash code），也叫散列码，哈希码是一个整形（int）。
  
  - hashCode的约定（Object规范）
  
    1. 在一个Java应用的执行期间，如果一个对象提供给equals做比较的信息没有被修改的话，该对象多次调用hashCode()方法，该方法必须始终如一返回同一个值。
  
    2. 如果两个对象根据equals(Object)方法是相等的，那么调用二者各自的hashCode()方法必须产生同一个整数结果。
  
    3. 并不要求根据equals()方法不相等的两个对象，调用二者各自的hashCode()方法必须产生不同的结果。然而，程序员应该意识到对于不同的对象产生不同的integer结果，有可能会提高hash table的性能。
  
  > 参考《Effective Java中文版》第3版，第10、11条

- 相关问题

  1. equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？

     因为重写的equals（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。

  2. hashCode()既然效率这么高为什么还要equals()呢？

     因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题，哈希冲突），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。一般来说：

     - equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。
     - hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。

  





### 5 == 和 equals 的区别是什么

- == : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)

- equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

  情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。

  情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。



> String类中的equals()方法是被重写过的。


### 6 重载（Overload）和重写（Override）的区别?

- 重载：发生在**同一个类中**，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分

- 重写：发生在**父子类中**，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。
- 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。


### 7 构造器（constructor）是否可被重写（override）?

构造器不能被继承，因此不能被重写，但可以被重载。



### 8 抽象类和接口有什么区别？

抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。

从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。

**不同点：**

抽象类：
1.抽象类中可以定义构造器
2.可以有抽象方法和具体方法
3.接口中的成员全都是 public 的
4.抽象类中可以定义成员变量
5.有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法
6.抽象类中可以包含静态方法
7.一个类只能继承一个抽象类

接口：
1.接口中不能定义构造器
2.方法全部都是抽象方法
3.抽象类中的成员可以是 private、默认、protected、public
4.接口中定义的成员变量实际上都是常量
5.接口中不能有静态方法
6.一个类可以实现多个接口

**相同点：**
1.不能够实例化
2.可以将抽象类和接口类型作为引用类型
3.一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要
被声明为抽象类

## 1.4 String相关



### String 和 StringBuffer、StringBuilder 的区别是什么？



### String 为什么是不可变的？



### IO流相关

### 反射相关



### 什么是反射机制？反射机制的应用场景有哪些？







## 



## 1.3 集合



## 1.2 异常



## 1.4 并发



## 1.5 JVM



# 2 数据库

## 2.1 MySQL



## 2.2 Redis



# 3 常用框架

## 3.1 Spring



## 3.2 Spring Boot



## 3.3 Spring Cloud



## 3.4 Mybatis





# 4 算法与数据结构



# 5 其他技术







# 6 补充知识点

## 6.1 什么是原码、反码、补码？

### 概念

原码、反码、补码是计算机中对数字的二进制表示方法。

- 原码：将最高位作为符号位（0表示正，1表示负），其它数字位代表数值本身的绝对值的数字表示方式。

- 反码：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。

- 补码：如果是整数，则表示方法和原码一样；如果是负数，则将数字的反码加上1（相当于将原码数值位取反然后在最低位加1）。



**反码的反码为原码，补码的补码为原码**



### 示例

假设为8-bit的整数

| 数字 | 原码       | 补码       | 反码       |
| ---- | ---------- | ---------- | ---------- |
| 6    | 0 000 0110 | 0 000 0110 | 0 000 0110 |
| -6   | 1 000 0110 | 1 111 1001 | 1 111 1010 |



### 二进制数的运算

二进制数的减法用两数的补码相加再去补码来完成，乘法用加法和位移实现，除法用减法和位移来实现。







# 参考



1. https://www.nowcoder.com/tutorial/94/ea1986fcff294f6292385703e94689e8
2. https://thinkwon.blog.csdn.net/article/details/104390612
3. https://how2j.cn/